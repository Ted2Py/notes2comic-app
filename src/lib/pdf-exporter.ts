// Type definitions for comic export
export interface ComicPanel {
  id: string;
  panelNumber: number;
  imageUrl: string;
  caption: string;
}

export interface ComicWithPanels {
  id: string;
  title: string;
  description: string | null;
  subject: string;
  artStyle: string;
  tone: string;
  isPublic: boolean;
  panels: ComicPanel[];
}

export interface ExportOptions {
  includeTitle?: boolean;
  watermark?: boolean;
  quality?: "low" | "medium" | "high";
}

export async function exportComicToPDF(
  comic: ComicWithPanels,
  options: ExportOptions = {}
): Promise<Blob> {
  const jsPDF = (await import("jspdf")).default;
  const pdf = new jsPDF({
    orientation: "landscape",
    unit: "mm",
    format: "a4",
  });

  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();

  // Add title page if requested
  if (options.includeTitle && comic.title) {
    pdf.setFontSize(24);
    pdf.text(comic.title, pageWidth / 2, pageHeight / 2, { align: "center" });

    if (comic.description) {
      pdf.setFontSize(14);
      pdf.text(comic.description, pageWidth / 2, pageHeight / 2 + 20, {
        align: "center",
      });
    }

    // Add metadata
    pdf.setFontSize(10);
    pdf.text(
      `Subject: ${comic.subject} | Style: ${comic.artStyle} | Tone: ${comic.tone}`,
      pageWidth / 2,
      pageHeight - 30,
      { align: "center" }
    );

    pdf.addPage();
  }

  // Add panels
  for (const panel of comic.panels) {
    // Fetch image and add to PDF
    const response = await fetch(panel.imageUrl);
    const blob = await response.blob();
    const base64 = await blobToBase64(blob);

    const imgProps = pdf.getImageProperties(base64);
    const imgWidth = pageWidth - 40;
    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;

    // Center image vertically
    const yPos = Math.max(20, (pageHeight - imgHeight) / 2);

    pdf.addImage(base64, getMimeType(blob), 20, yPos, imgWidth, imgHeight);

    // Add caption
    if (panel.caption) {
      pdf.setFontSize(12);
      const captionY = yPos + imgHeight + 15;
      pdf.text(panel.caption, pageWidth / 2, captionY, { align: "center" });
    }

    // Add watermark if requested
    if (options.watermark) {
      pdf.setFontSize(8);
      pdf.setTextColor(150, 150, 150);
      pdf.text(
        "Generated by Notes2Comic",
        pageWidth / 2,
        pageHeight - 10,
        { align: "center" }
      );
      pdf.setTextColor(0, 0, 0); // Reset color
    }

    if (panel !== comic.panels[comic.panels.length - 1]) {
      pdf.addPage();
    }
  }

  return pdf.output("blob");
}

function blobToBase64(blob: Blob): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result as string);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
}

function getMimeType(blob: Blob): string {
  if (blob.type) {
    // Convert image/webp to PNG for jsPDF compatibility
    if (blob.type === "image/webp") {
      return "PNG";
    }
    const ext = blob.type.split("/")[1]?.toUpperCase();
    if (ext && ["JPEG", "PNG", "JPG", "GIF"].includes(ext)) {
      return ext === "JPG" ? "JPEG" : ext;
    }
  }
  return "PNG";
}
